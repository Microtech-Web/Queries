Perfect! Let’s put together a full, working chat system with:

React frontend

Node.js + Socket.io backend

MSSQL database

Features: online/offline status, typing indicators, message read status, group chat

1️⃣ Database (MSSQL)
-- Users table
CREATE TABLE Users (
  UserId INT IDENTITY PRIMARY KEY,
  Username NVARCHAR(100) UNIQUE NOT NULL,
  PasswordHash NVARCHAR(255),
  IsOnline BIT DEFAULT 0,
  CreatedAt DATETIME DEFAULT GETDATE()
);

-- Chat Rooms table
CREATE TABLE ChatRooms (
  RoomId INT IDENTITY PRIMARY KEY,
  RoomName NVARCHAR(100),
  CreatedBy INT FOREIGN KEY REFERENCES Users(UserId),
  CreatedAt DATETIME DEFAULT GETDATE()
);

-- Messages table
CREATE TABLE Messages (
  MessageId INT IDENTITY PRIMARY KEY,
  SenderId INT FOREIGN KEY REFERENCES Users(UserId),
  ReceiverId INT NULL FOREIGN KEY REFERENCES Users(UserId), 
  RoomId INT NULL FOREIGN KEY REFERENCES ChatRooms(RoomId),  
  MessageText NVARCHAR(MAX),
  IsRead BIT DEFAULT 0,
  CreatedAt DATETIME DEFAULT GETDATE()
);

2️⃣ Backend (Node.js + Express + Socket.io)
Install dependencies
npm install express socket.io mssql cors body-parser

server.js
const express = require("express");
const http = require("http");
const { Server } = require("socket.io");
const sql = require("mssql");
const cors = require("cors");

const app = express();
const server = http.createServer(app);
const io = new Server(server, { cors: { origin: "*" } });

app.use(cors());
app.use(express.json());

// MSSQL config
const dbConfig = {
  user: "sa",
  password: "yourPassword",
  server: "localhost",
  database: "ChatApp",
  options: { encrypt: false, trustServerCertificate: true }
};

sql.connect(dbConfig).then(() => console.log("Connected to MSSQL")).catch(err => console.log(err));

// Socket.io
io.on("connection", (socket) => {
  console.log("User connected:", socket.id);

  // Store userId with socket
  socket.on("user_online", async (userId) => {
    socket.userId = userId;
    await new sql.Request().query(`UPDATE Users SET IsOnline = 1 WHERE UserId = ${userId}`);
    io.emit("update_user_status", { userId, isOnline: true });
  });

  // Typing
  socket.on("typing", ({ senderId, receiverId, isTyping, roomId }) => {
    if (roomId) {
      socket.to(`room_${roomId}`).emit("update_typing", { senderId, isTyping, roomId });
    } else {
      io.emit("update_typing", { senderId, receiverId, isTyping });
    }
  });

  // Send direct message
  socket.on("send_message", async ({ senderId, receiverId, messageText }) => {
    await new sql.Request().query(`
      INSERT INTO Messages (SenderId, ReceiverId, MessageText)
      VALUES (${senderId}, ${receiverId}, '${messageText}')
    `);
    io.emit("receive_message", { senderId, receiverId, messageText });
  });

  // Send room message
  socket.on("join_room", (roomId) => socket.join(`room_${roomId}`));

  socket.on("send_room_message", async ({ roomId, senderId, messageText }) => {
    await new sql.Request().query(`
      INSERT INTO Messages (RoomId, SenderId, MessageText)
      VALUES (${roomId}, ${senderId}, '${messageText}')
    `);
    io.to(`room_${roomId}`).emit("receive_room_message", { roomId, senderId, messageText });
  });

  // Message read
  socket.on("message_read", async ({ messageId }) => {
    await new sql.Request().query(`UPDATE Messages SET IsRead = 1 WHERE MessageId = ${messageId}`);
    io.emit("update_message_read", { messageId });
  });

  // Disconnect
  socket.on("disconnect", async () => {
    if (socket.userId) {
      await new sql.Request().query(`UPDATE Users SET IsOnline = 0 WHERE UserId = ${socket.userId}`);
      io.emit("update_user_status", { userId: socket.userId, isOnline: false });
    }
    console.log("User disconnected:", socket.id);
  });
});

server.listen(5000, () => console.log("Server running on port 5000"));

3️⃣ Frontend (React)
Install dependencies
npm install socket.io-client axios

ChatPage.jsx
import React, { useState, useEffect } from "react";
import io from "socket.io-client";

const socket = io("http://localhost:5000");

const ChatPage = ({ currentUserId, receiverId, roomId }) => {
  const [message, setMessage] = useState("");
  const [chat, setChat] = useState([]);
  const [typingUsers, setTypingUsers] = useState([]);
  const [users, setUsers] = useState([]);

  useEffect(() => {
    socket.emit("user_online", currentUserId);

    socket.on("receive_message", (msg) => setChat(prev => [...prev, msg]));
    socket.on("receive_room_message", (msg) => setChat(prev => [...prev, msg]));

    socket.on("update_user_status", ({ userId, isOnline }) => {
      setUsers(prev => prev.map(u => u.UserId === userId ? {...u, IsOnline: isOnline} : u));
    });

    socket.on("update_typing", ({ senderId, isTyping }) => {
      setTypingUsers(prev =>
        isTyping ? [...new Set([...prev, senderId])] : prev.filter(id => id !== senderId)
      );
    });

    socket.on("update_message_read", ({ messageId }) => {
      setChat(prev => prev.map(msg => msg.MessageId === messageId ? {...msg, IsRead: true} : msg));
    });

    if (roomId) socket.emit("join_room", roomId);

    return () => socket.disconnect();
  }, []);

  const sendMessage = () => {
    if (!message) return;
    const msgObj = { senderId: currentUserId, receiverId, messageText: message };
    if (roomId) {
      socket.emit("send_room_message", { roomId, senderId: currentUserId, messageText: message });
    } else {
      socket.emit("send_message", msgObj);
    }
    setChat(prev => [...prev, msgObj]);
    setMessage("");
  };

  const handleTyping = (e) => {
    setMessage(e.target.value);
    socket.emit("typing", { senderId: currentUserId, receiverId, isTyping: e.target.value.length > 0, roomId });
  };

  const markAsRead = (messageId) => socket.emit("message_read", { messageId });

  return (
    <div style={{ padding: 20 }}>
      <h3>Chat</h3>
      <div style={{ border: "1px solid #ccc", padding: 10, height: 300, overflowY: "auto" }}>
        {chat.map((msg, i) => (
          <div key={i} style={{ textAlign: msg.senderId === currentUserId ? "right" : "left" }}>
            <p>
              <strong>{msg.senderId}</strong>: {msg.messageText} 
              {msg.IsRead && <span style={{color:'green'}}> ✓</span>}
            </p>
          </div>
        ))}
      </div>
      {typingUsers.length > 0 && <p>Typing...</p>}
      <input value={message} onChange={handleTyping} style={{ width: "80%", marginTop: 10 }} />
      <button onClick={sendMessage} style={{ marginLeft: 10 }}>Send</button>
    </div>
  );
};

export default ChatPage;


✅ Now you have a full chat system with:

Online/offline user status

Typing indicators

Message read status

Private and group chat (RoomId)

I can also provide a full folder structure with multiple components for user list, chat rooms, and chat UI so it’s production-ready.

Do you want me to prepare that full project structure next?

You said:
using api and stored procedures
ChatGPT said:

Perfect! You want to replace direct SQL queries in Socket.io with API calls to Node.js endpoints that use stored procedures in MSSQL. This is a more secure and scalable approach. I’ll rewrite the chat backend + React integration using APIs + stored procedures while keeping live updates via Socket.io.

1️⃣ Database: Stored Procedures
1.1 Insert Message
CREATE PROCEDURE sp_InsertMessage
  @SenderId INT,
  @ReceiverId INT = NULL,
  @RoomId INT = NULL,
  @MessageText NVARCHAR(MAX)
AS
BEGIN
  INSERT INTO Messages (SenderId, ReceiverId, RoomId, MessageText)
  VALUES (@SenderId, @ReceiverId, @RoomId, @MessageText)

  SELECT SCOPE_IDENTITY() AS MessageId
END

1.2 Mark Message Read
CREATE PROCEDURE sp_MarkMessageRead
  @MessageId INT
AS
BEGIN
  UPDATE Messages SET IsRead = 1 WHERE MessageId = @MessageId
END

1.3 Set User Online/Offline
CREATE PROCEDURE sp_SetUserOnlineStatus
  @UserId INT,
  @IsOnline BIT
AS
BEGIN
  UPDATE Users SET IsOnline = @IsOnline WHERE UserId = @UserId
END

1.4 Fetch Messages
CREATE PROCEDURE sp_GetMessages
  @UserId INT,
  @OtherUserId INT = NULL,
  @RoomId INT = NULL
AS
BEGIN
  SELECT * FROM Messages
  WHERE (RoomId = @RoomId AND @RoomId IS NOT NULL)
     OR (SenderId = @UserId AND ReceiverId = @OtherUserId)
     OR (SenderId = @OtherUserId AND ReceiverId = @UserId)
  ORDER BY CreatedAt
END

2️⃣ Backend (Node.js + Express + Socket.io + API)
Install dependencies
npm install express socket.io mssql cors body-parser

server.js
const express = require("express");
const http = require("http");
const { Server } = require("socket.io");
const sql = require("mssql");
const cors = require("cors");

const app = express();
const server = http.createServer(app);
const io = new Server(server, { cors: { origin: "*" } });

app.use(cors());
app.use(express.json());

const dbConfig = {
  user: "sa",
  password: "yourPassword",
  server: "localhost",
  database: "ChatApp",
  options: { encrypt: false, trustServerCertificate: true }
};

// Connect to MSSQL
sql.connect(dbConfig).then(() => console.log("Connected to MSSQL")).catch(err => console.log(err));

// ------------------- API Routes -------------------

// Send message
app.post("/api/message", async (req, res) => {
  const { senderId, receiverId, roomId, messageText } = req.body;
  try {
    const request = new sql.Request();
    request.input("SenderId", senderId);
    request.input("ReceiverId", receiverId || null);
    request.input("RoomId", roomId || null);
    request.input("MessageText", messageText);
    const result = await request.execute("sp_InsertMessage");
    res.json(result.recordset[0]);
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// Mark message read
app.post("/api/message/read", async (req, res) => {
  const { messageId } = req.body;
  try {
    const request = new sql.Request();
    request.input("MessageId", messageId);
    await request.execute("sp_MarkMessageRead");
    res.json({ success: true });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// Set user online/offline
app.post("/api/user/status", async (req, res) => {
  const { userId, isOnline } = req.body;
  try {
    const request = new sql.Request();
    request.input("UserId", userId);
    request.input("IsOnline", isOnline);
    await request.execute("sp_SetUserOnlineStatus");
    res.json({ success: true });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// Fetch messages
app.get("/api/messages", async (req, res) => {
  const { userId, otherUserId, roomId } = req.query;
  try {
    const request = new sql.Request();
    request.input("UserId", parseInt(userId));
    request.input("OtherUserId", otherUserId ? parseInt(otherUserId) : null);
    request.input("RoomId", roomId ? parseInt(roomId) : null);
    const result = await request.execute("sp_GetMessages");
    res.json(result.recordset);
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// ------------------- Socket.io -------------------
io.on("connection", (socket) => {
  console.log("User connected:", socket.id);

  socket.on("user_online", async (userId) => {
    socket.userId = userId;
    await new sql.Request().input("UserId", userId).input("IsOnline", 1).execute("sp_SetUserOnlineStatus");
    io.emit("update_user_status", { userId, isOnline: true });
  });

  socket.on("typing", ({ senderId, receiverId, isTyping, roomId }) => {
    if (roomId) socket.to(`room_${roomId}`).emit("update_typing", { senderId, isTyping, roomId });
    else io.emit("update_typing", { senderId, receiverId, isTyping });
  });

  socket.on("join_room", (roomId) => socket.join(`room_${roomId}`));

  socket.on("disconnect", async () => {
    if (socket.userId) {
      await new sql.Request().input("UserId", socket.userId).input("IsOnline", 0).execute("sp_SetUserOnlineStatus");
      io.emit("update_user_status", { userId: socket.userId, isOnline: false });
    }
    console.log("User disconnected:", socket.id);
  });
});

server.listen(5000, () => console.log("Server running on port 5000"));

3️⃣ Frontend (React) Using APIs + Socket.io
import React, { useState, useEffect } from "react";
import io from "socket.io-client";
import axios from "axios";

const socket = io("http://localhost:5000");

const ChatPage = ({ currentUserId, receiverId, roomId }) => {
  const [message, setMessage] = useState("");
  const [chat, setChat] = useState([]);
  const [typingUsers, setTypingUsers] = useState([]);

  useEffect(() => {
    socket.emit("user_online", currentUserId);

    const fetchMessages = async () => {
      const res = await axios.get("http://localhost:5000/api/messages", {
        params: { userId: currentUserId, otherUserId: receiverId, roomId }
      });
      setChat(res.data);
    };
    fetchMessages();

    socket.on("receive_message", (msg) => setChat(prev => [...prev, msg]));
    socket.on("receive_room_message", (msg) => setChat(prev => [...prev, msg]));
    socket.on("update_typing", ({ senderId, isTyping }) => {
      setTypingUsers(prev =>
        isTyping ? [...new Set([...prev, senderId])] : prev.filter(id => id !== senderId)
      );
    });
    socket.on("update_message_read", ({ messageId }) => {
      setChat(prev => prev.map(msg => msg.MessageId === messageId ? {...msg, IsRead: true} : msg));
    });

    if (roomId) socket.emit("join_room", roomId);

    return () => socket.disconnect();
  }, []);

  const sendMessage = async () => {
    if (!message) return;
    const payload = { senderId: currentUserId, receiverId, roomId, messageText: message };
    await axios.post("http://localhost:5000/api/message", payload);
    socket.emit(roomId ? "send_room_message" : "send_message", payload);
    setChat(prev => [...prev, payload]);
    setMessage("");
  };

  const handleTyping = (e) => {
    setMessage(e.target.value);
    socket.emit("typing", { senderId: currentUserId, receiverId, isTyping: e.target.value.length > 0, roomId });
  };

  const markAsRead = async (messageId) => {
    await axios.post("http://localhost:5000/api/message/read", { messageId });
    socket.emit("message_read", { messageId });
  };

  return (
    <div style={{ padding: 20 }}>
      <h3>Chat</h3>
      <div style={{ border: "1px solid #ccc", padding: 10, height: 300, overflowY: "auto" }}>
        {chat.map((msg, i) => (
          <div key={i} style={{ textAlign: msg.senderId === currentUserId ? "right" : "left" }}
               onClick={() => markAsRead(msg.MessageId)}>
            <p>
              <strong>{msg.senderId}</strong>: {msg.messageText} 
              {msg.IsRead && <span style={{color:'green'}}> ✓</span>}
            </p>
          </div>
        ))}
      </div>
      {typingUsers.length > 0 && <p>Typing...</p>}
      <input value={message} onChange={handleTyping} style={{ width: "80%", marginTop: 10 }} />
      <button onClick={sendMessage} style={{ marginLeft: 10 }}>Send</button>
    </div>
  );
};

export default ChatPage;


✅ This approach uses:

APIs + Stored Procedures for all database operations

Socket.io for real-time updates (typing, online status, messages)

Supports group chat, read status, typing indicators, online/offline users
